Exploring what happens when packets are lost

Packets are lost when either link drops them due to insufficient buffer size or due to stochastic loss (not implementing now)

#########################################################################

A HACKY SOLUTION
Rather than look at all the acks in SwitchedSender::receive_feedback which is both inefficient and tedious, I plan to account for them when the decision for losing them is made. This is not the modular option but is very efficient and easy to implement.

Flow of information about a lost packet:
1. Link decides to drop a packet, either due to buffer overflow or due to stochastic loss


ALTERNATIVE SOLUTION (THIS IS BEING ADOPTED NOW)
In this plan, I propose to drop packets as they should be dropped. That is, when Link decides to drop a packet, it simply does not forward it. When receive_feedback parses the packets that Receiver received, it (assuming no reordering) notes the number of lost packets (linear time here, but shouldn't change the overall order of the algorithm). In ByteSwitchedSender we can simply increase pacets_sent_cap_ by that amount to ensure that the extra sumber of packets are transmitted. In this proposal, I do not plan to work with TimeSwitchedSender as it also does not seem to make sense to talk about packet loss in such a system in such a manner.
Further I modify Utility so that it keeps track of the loss rate. This is done by looking at the sequence number of the received packets

Note: Unlike what is described above, right now, I am not keeping track of lost packets. Hopefully the results should be similar enough. This is for speed purposes.

#########################################################################

Rough Change Notes For Making the Buffer Finite:
Link
	- Modify the _limit while constructing Link object
	- To make above modification, I need to change NetConfig (done), Network (done), Evaluator (done), ConfigurationRange (done), rat-runner.cc(done), remy.cc (done)
	- What should the default buffer size be like? Ans. 10% ofbandwidth-delay product
Memory
	- Define a proper metric for the loss rate
	- Make the comparison operators consider loss rate too (after defining a proper metric)
	- See how large the packets vector is going to be in packets_received. If this is too short, our method of tracking the number of lost packets will fail
SenderGang
	- Make the senders ByteSwitchedSender because that makes more sense here, especially if I implement the packet loss detector.
ProtocolBuffers
	- ConfigRange's DNA needs to be changed among the DNAs of other things
Evaluator
	- In initializing the configs, I only take the lower value of link_limit to restrict the number of non-random configurations on which Remy runs (from 8 to 4)


#########################################################################

ADDING LOSS AS A SIGNAL

The Signal - Fraction of packets lost in the previous RTT (Can be loose on the precise value of 'since previous RTT'. The algorithm should not be very sensitive to this). More specifically, it is the fraction of packets lost between the last acknowledged packet and one RTT estimate before that ( either ewma of rtt or _min_rtt*_rtt_ratio )

Note: This fraction is scaled to 163840, so that it matches with the other signals

I will also remove slow_rewma

Things Needing Change
	- memory.cc and memory.h - Yes (naturally)
	- memoryrange? - Nope. Very modular and generic code
	- WhiskerTree? - Nope
	- Whisker - Yes
	- WhiskerImprover? - Nope
	- Ratbreeder? - Nope
	- Rat - Nope
	- rat-templates.cc, rat-runner.cc, remy.cc, scoring-example.cc - Nope
	- Network, SenderGang, SenderGangofGangs, ConfigRange, Aimd, Evaluator, Link, Packet, Receiver, Utility - Nope
	- Protoc Definition - Probably

Things to Change When Changing Rignals to Remy
Memory
	- First modify the varaibles in the class definition
	- packets_received: The main site of action where all the variables that are being tracked are changed
	- str: for printing the quantities
	- datasize: the number of signals that we are giving remy
	- Modify MAX_MEMORY to suit new needs
	- The constructors
	- The DNA generator

Whisker
	- Whisker::next_generation - modify the for loops that generate the options
	- No need to modify this at all!! But I feel too bad about erasing this section becaue it is half a day's work. So this stays.

Protocol Buffers
	- Just change RemyBuffers::Memory to the updated signals. Not much to be done here	

Things Actually Changed
	- Added _num_packets_received, _num_packets_lost as variables
	- Removed _num_packets_lost and _num_packets_received
	- Added _lost_packets and _all_packets_in_rtt_window which are queues of packets
	- Added an _rtt_estimate
	- Made a queue (_lost_packets) that has all packets from latest received to one rtt estimate before that
	- Removed _largest_ack as _all_packets_in_rtt_window is now there
	- Modified RemyBuffers::Memory
	-Added _largest_ack back as _all_packets_in_rtt_window can get empty too

Points To Note
	- WARNING - question - does having extra elements in the object affect whatever is done with the calculated hash value? This function doesn't seem to be called from anywhere

###################################################################################

ADDING STOCHASTIC LOSS
 ( to the link )

This should be easy enough as the link can simply drop a packet and the rest of the system can handle it. But there are two primary challenges:

     - The random number generator should be in sync with what is there in the rest of the system. (done)
     - Prefferably, the loss rate should come from the ConfigureRange system. This is just hard-work. Let's see if it is worth it. (done)
